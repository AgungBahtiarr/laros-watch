---
import Layout from "../layouts/Layout.astro";
import type { Node, Connection } from "../types";

const apiBaseUrl =
    import.meta.env.PUBLIC_API_BASE_URL || "http://localhost:3000";
const osrmApiUrl = import.meta.env.PUBLIC_OSRM_API_URL;

// Fetch nodes and connections
const [nodesResponse, connectionsResponse] = await Promise.all([
    fetch(`${apiBaseUrl}/api/nodes`),
    fetch(`${apiBaseUrl}/api/nodes/connections`),
]);

const nodes: Node[] = await nodesResponse.json();
const connections: Connection[] = await connectionsResponse.json();

const nodesWithLocation = nodes.filter((node) => node.lat && node.lng);
const nodeMap = new Map(nodes.map((node) => [node.id, node]));

// Prepare route promises
const routePromises = connections.map((conn) => {
    const nodeA = nodeMap.get(conn.deviceAId);
    const nodeB = nodeMap.get(conn.deviceBId);

    if (nodeA && nodeB && osrmApiUrl) {
        const url = `${osrmApiUrl}/${nodeA.lng},${nodeA.lat};${nodeB.lng},${nodeB.lat}?overview=full&geometries=geojson`;
        return fetch(url)
            .then((res) => res.json())
            .catch((error) => {
                console.error("OSRM API Fetch Error for URL:", url, error);
                return null;
            });
    }
    return Promise.resolve(null);
});

const routeResults = await Promise.all(routePromises);

const routes = routeResults
    .map((result, index) => {
        if (result && result.routes && result.routes.length > 0) {
            return {
                geometry: result.routes[0].geometry,
                distance: result.routes[0].distance, // in meters
                connectionId: connections[index].id,
            };
        }
        return null;
    })
    .filter(Boolean);
---

<Layout title="Nodes Map">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6">Nodes Map & Connections</h1>
        <div id="map" class="h-[600px] rounded-lg shadow-lg mb-8"></div>

        <!-- Connections Table -->
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold">Connections</h2>
            <label for="add-connection-modal" class="btn btn-primary"
                >Add Connection</label
            >
        </div>
        <div class="overflow-x-auto">
            <table class="table w-full">
                <thead>
                    <tr>
                        <th>Description</th>
                        <th>Device A</th>
                        <th>Device B</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {
                        connections.map((conn) => (
                            <tr data-connection-id={conn.id}>
                                <td>{conn.description}</td>
                                <td>
                                    {nodeMap.get(conn.deviceAId)?.name ||
                                        "Unknown"}
                                </td>
                                <td>
                                    {nodeMap.get(conn.deviceBId)?.name ||
                                        "Unknown"}
                                </td>
                                <td class="flex gap-2">
                                    <button class="btn btn-sm btn-success btn-view">
                                        View
                                    </button>
                                    <button class="btn btn-sm btn-info btn-edit">
                                        Edit
                                    </button>
                                    <button class="btn btn-sm btn-error btn-delete">
                                        Delete
                                    </button>
                                    <button class="btn btn-sm btn-warning btn-find-point">
                                        Find Point
                                    </button>
                                </td>
                            </tr>
                        ))
                    }
                </tbody>
            </table>
        </div>
    </div>

    <!-- Add/Edit Modal -->
    <input type="checkbox" id="add-connection-modal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box w-11/12 max-w-2xl">
            <h3 class="font-bold text-lg" id="modal-title">
                Add New Connection
            </h3>
            <form id="connection-form">
                <input type="hidden" id="connection-id" name="connectionId" />
                <div class="form-control">
                    <label class="label" for="description">Description</label>
                    <input
                        type="text"
                        id="description"
                        name="description"
                        class="input input-bordered"
                        required
                    />
                </div>
                <div class="grid grid-cols-2 gap-4 mt-4">
                    <div class="form-control">
                        <label class="label" for="deviceAId">Device A</label>
                        <select
                            id="deviceAId"
                            name="deviceAId"
                            class="select select-bordered"
                            required
                        >
                            <option disabled selected>Select Device</option>
                            {
                                nodes.map((node) => (
                                    <option value={node.id}>{node.name}</option>
                                ))
                            }
                        </select>
                    </div>
                    <div class="form-control">
                        <label class="label" for="portAId">Port A</label>
                        <select
                            id="portAId"
                            name="portAId"
                            class="select select-bordered"
                            required
                            disabled></select>
                    </div>
                    <div class="form-control">
                        <label class="label" for="deviceBId">Device B</label>
                        <select
                            id="deviceBId"
                            name="deviceBId"
                            class="select select-bordered"
                            required
                        >
                            <option disabled selected>Select Device</option>
                            {
                                nodes.map((node) => (
                                    <option value={node.id}>{node.name}</option>
                                ))
                            }
                        </select>
                    </div>
                    <div class="form-control">
                        <label class="label" for="portBId">Port B</label>
                        <select
                            id="portBId"
                            name="portBId"
                            class="select select-bordered"
                            required
                            disabled></select>
                    </div>
                </div>
                <div class="form-control mt-4">
                    <label class="label" for="odpPath"
                        >ODP Path (comma-separated IDs)</label
                    >
                    <input
                        type="text"
                        id="odpPath"
                        name="odpPath"
                        class="input input-bordered"
                    />
                </div>
                <div class="modal-action">
                    <label for="add-connection-modal" class="btn">Cancel</label>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Find Point Modal -->
    <input type="checkbox" id="find-point-modal" class="modal-toggle" />
    <div class="modal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Find Point on Route</h3>
            <form id="find-point-form">
                <input type="hidden" id="find-point-connection-id" />
                <div class="form-control">
                    <label class="label" for="start-node-select"
                        >Start From</label
                    >
                    <select
                        id="start-node-select"
                        class="select select-bordered"
                    >
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <div class="form-control mt-4">
                    <label class="label" for="distance-input"
                        >Distance (meters)</label
                    >
                    <input
                        type="number"
                        id="distance-input"
                        class="input input-bordered"
                        required
                    />
                </div>
                <div class="modal-action">
                    <label for="find-point-modal" class="btn">Cancel</label>
                    <button type="submit" class="btn btn-primary">Find</button>
                </div>
            </form>
        </div>
    </div>

    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script is:inline src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    ></script>
    <script is:inline src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <script
        define:vars={{
            nodes,
            connections,
            nodesWithLocation,
            routes,
            apiBaseUrl,
        }}
    >
        // --- Helper Functions ---
        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            let color = "#";
            for (let i = 0; i < 3; i++) {
                const value = (hash >> (i * 8)) & 0xff;
                color += ("00" + value.toString(16)).substr(-2);
            }
            return color;
        }

        // --- Map Initialization ---
        const map = L.map("map").setView([-2.5, 118], 5); // Default view of Indonesia
        if (nodesWithLocation.length > 0) {
            map.setView(
                [nodesWithLocation[0].lat, nodesWithLocation[0].lng],
                8,
            );
        }
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "&copy; OpenStreetMap",
        }).addTo(map);
        L.tileLayer("", {
            attribution: "PT. Lare Osing Ndo.",
        }).addTo(map);
        const greenIcon = new L.Icon({
            iconUrl:
                "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
            shadowUrl:
                "https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41],
        });

        const redIcon = new L.Icon({
            iconUrl:
                "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png",
            shadowUrl:
                "https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41],
        });

        nodesWithLocation.forEach((node) => {
            const icon = node.status ? greenIcon : redIcon;
            L.marker([node.lat, node.lng], { icon: icon })
                .addTo(map)
                .bindPopup(
                    `<b>${node.name}</b><br>Status: ${node.status ? "Up" : "Down"}`,
                );
        });
        let selectedRouteLayer = null;
        map.on("click", () => {
            if (selectedRouteLayer) {
                selectedRouteLayer.setStyle(selectedRouteLayer.originalStyle);
                selectedRouteLayer = null;
            }
        });
        const routeLayers = {};
        if (routes && routes.length > 0) {
            routes.forEach((routeData) => {
                if (routeData && routeData.geometry) {
                    const distanceInKm = (routeData.distance / 1000).toFixed(2);
                    const conn = connections.find(
                        (c) => c.id === routeData.connectionId,
                    );
                    const popupContent = `<b>${conn?.description || "Connection"}</b><br>Distance: ${distanceInKm} km`;
                    const color = stringToColor(
                        routeData.connectionId.toString(),
                    );

                    const routeLayer = L.geoJSON(routeData.geometry, {
                        style: { color: color, weight: 3, opacity: 0.8 },
                        onEachFeature: function (feature, layer) {
                            layer.bindPopup(popupContent);
                            const originalStyle = {
                                color: color,
                                weight: 3,
                                opacity: 0.8,
                            };
                            layer.originalStyle = originalStyle;

                            layer.on("click", (e) => {
                                if (selectedRouteLayer) {
                                    selectedRouteLayer.setStyle(
                                        selectedRouteLayer.originalStyle,
                                    );
                                }
                                layer.setStyle({
                                    color: "#FFFF00",
                                    weight: 5,
                                    opacity: 1,
                                });
                                layer.bringToFront();
                                selectedRouteLayer = layer;
                                if (e.originalEvent) {
                                    L.DomEvent.stopPropagation(e); // prevent map click from firing
                                }
                            });
                        },
                    }).addTo(map);
                    routeLayers[routeData.connectionId] = routeLayer;
                }
            });
        }

        // --- Modal and Form Logic ---
        const nodeMap = new Map(nodes.map((node) => [node.id, node]));
        const connectionMap = new Map(
            connections.map((conn) => [conn.id, conn]),
        );
        const form = document.getElementById("connection-form");
        const modalToggle = document.getElementById("add-connection-modal");
        const modalTitle = document.getElementById("modal-title");
        const connectionIdInput = document.getElementById("connection-id");
        const descriptionInput = document.getElementById("description");
        const deviceASelect = document.getElementById("deviceAId");
        const portASelect = document.getElementById("portAId");
        const deviceBSelect = document.getElementById("deviceBId");
        const portBSelect = document.getElementById("portBId");
        const odpPathInput = document.getElementById("odpPath");

        const findPointModalToggle =
            document.getElementById("find-point-modal");
        const findPointForm = document.getElementById("find-point-form");
        const findPointConnectionIdInput = document.getElementById(
            "find-point-connection-id",
        );
        const startNodeSelect = document.getElementById("start-node-select");
        const distanceInput = document.getElementById("distance-input");

        function populatePorts(deviceSelect, portSelect, selectedPortId) {
            const selectedNodeId = deviceSelect.value;
            portSelect.innerHTML = "";
            portSelect.disabled = true;
            if (!selectedNodeId) return;

            const node = nodeMap.get(parseInt(selectedNodeId));
            if (node && node.interfaces) {
                portSelect.disabled = false;
                node.interfaces.forEach((iface) => {
                    const option = document.createElement("option");
                    option.value = iface.id;
                    option.textContent = `${iface.ifName} (${iface.ifDescr})`;
                    if (iface.id === selectedPortId) {
                        option.selected = true;
                    }
                    portSelect.appendChild(option);
                });
            }
        }

        function resetForm() {
            form.reset();
            connectionIdInput.value = "";
            modalTitle.textContent = "Add New Connection";
            portASelect.innerHTML = "";
            portASelect.disabled = true;
            portBSelect.innerHTML = "";
            portBSelect.disabled = true;
        }

        deviceASelect.addEventListener("change", () =>
            populatePorts(deviceASelect, portASelect),
        );
        deviceBSelect.addEventListener("change", () =>
            populatePorts(deviceBSelect, portBSelect),
        );
        modalToggle.addEventListener("change", () => {
            if (!modalToggle.checked) {
                resetForm();
            }
        });

        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const connectionId = connectionIdInput.value;
            const isEdit = !!connectionId;
            const formData = new FormData(form);
            const data = {
                deviceAId: parseInt(formData.get("deviceAId")),
                portAId: parseInt(formData.get("portAId")),
                deviceBId: parseInt(formData.get("deviceBId")),
                portBId: parseInt(formData.get("portBId")),
                description: formData.get("description"),
                odpPath: formData
                    .get("odpPath")
                    .split(",")
                    .map((s) => parseInt(s.trim()))
                    .filter((n) => !isNaN(n)),
            };

            const url = isEdit
                ? `${apiBaseUrl}/api/nodes/connections/${connectionId}`
                : `${apiBaseUrl}/api/nodes/connections`;
            const method = isEdit ? "PUT" : "POST";

            try {
                const response = await fetch(url, {
                    method: method,
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(data),
                });
                if (!response.ok)
                    throw new Error(
                        `Failed to ${isEdit ? "update" : "save"} connection`,
                    );
                modalToggle.checked = false;
                location.reload();
            } catch (error) {
                console.error(error);
                alert("Error: " + error.message);
            }
        });

        // --- Table Button Logic ---
        // View Logic
        document.querySelectorAll(".btn-view").forEach((button) => {
            button.addEventListener("click", (e) => {
                const row = e.target.closest("tr");
                const connectionId = row.dataset.connectionId;
                const routeLayer = routeLayers[connectionId];
                if (routeLayer) {
                    const bounds = routeLayer.getBounds();
                    map.fitBounds(bounds.pad(0.1));
                    // We need to open the popup on the actual inner layer, not the GeoJSON group
                    routeLayer.eachLayer((layer) => {
                        layer.fire("click");
                        layer.openPopup();
                    });
                }
            });
        });

        // Delete Logic
        document.querySelectorAll(".btn-delete").forEach((button) => {
            button.addEventListener("click", async (e) => {
                const row = e.target.closest("tr");
                const connectionId = row.dataset.connectionId;
                if (
                    confirm("Are you sure you want to delete this connection?")
                ) {
                    try {
                        const response = await fetch(
                            `${apiBaseUrl}/api/nodes/connections/${connectionId}`,
                            { method: "DELETE" },
                        );
                        if (!response.ok)
                            throw new Error("Failed to delete connection");
                        location.reload();
                    } catch (error) {
                        console.error(error);
                        alert("Error: " + error.message);
                    }
                }
            });
        });

        // Edit Logic
        document.querySelectorAll(".btn-edit").forEach((button) => {
            button.addEventListener("click", (e) => {
                const row = e.target.closest("tr");
                const connectionId = parseInt(row.dataset.connectionId);
                const conn = connectionMap.get(connectionId);

                if (conn) {
                    modalTitle.textContent = "Edit Connection";
                    connectionIdInput.value = conn.id;
                    descriptionInput.value = conn.description;
                    deviceASelect.value = conn.deviceAId;
                    populatePorts(deviceASelect, portASelect, conn.portAId);
                    deviceBSelect.value = conn.deviceBId;
                    populatePorts(deviceBSelect, portBSelect, conn.portBId);
                    odpPathInput.value = conn.odpPath?.join(", ") || "";
                    modalToggle.checked = true;
                }
            });
        });

        // Find Point Logic
        document.querySelectorAll(".btn-find-point").forEach((button) => {
            button.addEventListener("click", (e) => {
                const row = e.target.closest("tr");
                const connectionId = parseInt(row.dataset.connectionId);
                const conn = connectionMap.get(connectionId);

                if (!conn) return;

                // Populate the modal
                findPointConnectionIdInput.value = connectionId;
                startNodeSelect.innerHTML = ""; // Clear previous options

                const nodeA = nodeMap.get(conn.deviceAId);
                const nodeB = nodeMap.get(conn.deviceBId);

                if (nodeA) {
                    const optionA = document.createElement("option");
                    optionA.value = nodeA.id;
                    optionA.textContent = nodeA.name;
                    startNodeSelect.appendChild(optionA);
                }
                if (nodeB) {
                    const optionB = document.createElement("option");
                    optionB.value = nodeB.id;
                    optionB.textContent = nodeB.name;
                    startNodeSelect.appendChild(optionB);
                }

                // Show the modal
                findPointModalToggle.checked = true;
            });
        });

        findPointForm.addEventListener("submit", (e) => {
            e.preventDefault();

            const connectionId = parseInt(findPointConnectionIdInput.value);
            const startNodeId = parseInt(startNodeSelect.value);
            const distanceMeters = parseFloat(distanceInput.value);

            if (isNaN(distanceMeters)) {
                alert("Invalid distance.");
                return;
            }

            const routeData = routes.find(
                (r) => r.connectionId === connectionId,
            );
            if (!routeData) {
                alert("Route not found for this connection.");
                return;
            }

            if (distanceMeters > routeData.distance) {
                alert(
                    `Distance is greater than route distance (${routeData.distance.toFixed(
                        2,
                    )}m)`,
                );
                return;
            }

            const conn = connectionMap.get(connectionId);
            let line = routeData.geometry;

            // If the user selected Node B as the start, we need to reverse the line
            if (startNodeId === conn.deviceBId) {
                const reversedCoords = [...line.coordinates].reverse();
                line = turf.lineString(reversedCoords);
            }

            const point = turf.along(line, distanceMeters, { units: "meters" });

            // Add marker with shareable popup
            const lat = point.geometry.coordinates[1];
            const lng = point.geometry.coordinates[0];
            const googleMapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;

            const popupContent = document.createElement("div");
            popupContent.innerHTML = `
                Point at ${distanceMeters}m from ${
                    startNodeSelect.options[startNodeSelect.selectedIndex].text
                }
                <br><br>
                <button class="btn btn-sm btn-primary copy-gmaps-link-btn">Copy Google Maps Link</button>
            `;

            const copyButton = popupContent.querySelector(
                ".copy-gmaps-link-btn",
            );
            copyButton.addEventListener("click", () => {
                navigator.clipboard
                    .writeText(googleMapsUrl)
                    .then(() => {
                        alert("Google Maps link copied to clipboard!");
                    })
                    .catch((err) => {
                        console.error("Failed to copy text: ", err);
                        alert("Failed to copy link.");
                    });
            });

            L.marker([lat, lng]).addTo(map).bindPopup(popupContent).openPopup();

            // Fly to the point
            map.flyTo([lat, lng], 15);

            // Close the modal
            findPointModalToggle.checked = false;
            findPointForm.reset();
        });
    </script>
</Layout>
