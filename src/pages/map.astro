---
import Layout from "@/layouts/Layout.astro";
import MapPage from "@/components/MapPage.svelte";
import type { Node, Connection, Waypoint } from "@/types";

const apiBaseUrl = import.meta.env.PUBLIC_API_BASE_URL;
const osrmApiUrl = import.meta.env.PUBLIC_OSRM_API_URL;
const graphhopperApiUrl = import.meta.env.PUBLIC_GRAPHHOPPER_URL;

// Fetch nodes and connections
const token = Astro.cookies.get("authToken");

const [
    nodesResponse,
    connectionsResponse,
    waypointsResponse,
    vlanTraceResponse,
] = await Promise.allSettled([
    fetch(`${apiBaseUrl}/api/nodes`, {
        headers: { Authorization: `Basic ${token?.value}` },
    }),
    fetch(`${apiBaseUrl}/api/nodes/connections`, {
        headers: { Authorization: `Basic ${token?.value}` },
    }),
    fetch(`${apiBaseUrl}/api/nodes/waypoints`, {
        headers: { Authorization: `Basic ${token?.value}` },
    }),
    fetch(`${apiBaseUrl}/api/vlan-trace`, {
        headers: { Authorization: `Basic ${token?.value}` },
    }),
]);

const nodes: Node[] =
    nodesResponse.status === "fulfilled" && nodesResponse.value.ok
        ? await nodesResponse.value.json()
        : [];
const connections: Connection[] =
    connectionsResponse.status === "fulfilled" && connectionsResponse.value.ok
        ? await connectionsResponse.value.json()
        : [];
const waypoints: Waypoint[] =
    waypointsResponse.status === "fulfilled" && waypointsResponse.value.ok
        ? await waypointsResponse.value.json()
        : [];

let vlanTraceData = {};
if (vlanTraceResponse.status === "fulfilled" && vlanTraceResponse.value.ok) {
    vlanTraceData = await vlanTraceResponse.value.json();
} else {
    console.error(
        "Failed to fetch VLAN trace data:",
        vlanTraceResponse.status === "rejected"
            ? vlanTraceResponse.reason
            : await (vlanTraceResponse.value as any).text(),
    );
}
// console.log("--- VLAN TRACE DATA ---", vlanTraceData);

const nodesWithLocation = nodes.filter((node) => node.lat && node.lng);

// Group connections by device and port pair, and select the one with Waypoint path if available
const connectionGroups = new Map<string, Connection[]>();
connections.forEach((conn) => {
    const pair1 = `${conn.deviceAId}:${conn.interfaceAId}`;
    const pair2 = `${conn.deviceBId}:${conn.interfaceBId}`;
    const pairKey = [pair1, pair2].sort().join("-");
    if (!connectionGroups.has(pairKey)) {
        connectionGroups.set(pairKey, []);
    }
    connectionGroups.get(pairKey)!.push(conn);
});

const uniqueConnections: Connection[] = [];
for (const group of connectionGroups.values()) {
    const withWaypoint = group.find(
        (c) =>
            c.waypointPath &&
            Array.isArray(c.waypointPath) &&
            c.waypointPath.length > 0,
    );
    if (withWaypoint) {
        uniqueConnections.push(withWaypoint);
    } else if (group.length > 0) {
        uniqueConnections.push(group[0]);
    }
}
---

<Layout title="Nodes Map">
    <MapPage
        client:only="svelte"
        nodes={nodes}
        connections={uniqueConnections}
        nodesWithLocation={nodesWithLocation}
        apiBaseUrl={apiBaseUrl}
        osrmApiUrl={osrmApiUrl}
        graphhopperApiUrl={graphhopperApiUrl}
        waypoints={waypoints}
        vlanTraceData={vlanTraceData}
        token={token?.value}
    />
</Layout>
